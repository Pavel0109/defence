\section{Хэш-функция. Коллизия.  Парадокс дней рождения. Хэш-функция Стрибог.}

\subsection{Хэш-функция. Коллизия. }

Хэш-функциеи? (англ. hash function) называется отображение, переводящее аргумент произвольной длины в значение фиксированной длины.
Коллизией хэш-функции называется пара значений аргумента, дающая одинаковый выход хэш-функции. Коллизии есть у любых хэш-функций, если количество различных значении? аргумента превышает возможное количество значении? результата функции (принцип Дирихле). А если не превышает, то и нет смысла использовать хэш-функцию.

В программировании к свойствам хорошей хэш-функции относят:
\begin{itemize}
\item быструю скорость работы;
\item минимальное число коллизий.
\end{itemize}

Криптографически стойкой хэш-функцией $H(x)$	 называется хэш-функция, имеющая следующие свойства: 

\begin{itemize}
\item однонаправленность: вычислительно невозможно по значению функции найти прообраз;
\item слабая устойчивость к коллизиям (слабо бесконфликтная функция): для заданного аргумента $x$ вычислительно невозможно найти другой аргумент $y \neq x : H(x) = H(y)$;
\item сильная устойчивость к коллизиям (сильно бесконфликтная функция): вычислительно невозможно найти пару разных аргументов $y \neq x : H(x) = H(y)$.
\end{itemize}

Если k -битовая криптографическая хэш-функция имеет равномерное распределение выходных хэш-значении? по всем сообщениям, то, согласно парадоксу дней рождения (см. раздел А.2 в приложении), среди 
$$
n _{1/2} \approx \sqrt{2\ln2}\cdot 2^{k/2}
$$

случайных сообщений с вероятностью больше 1/2 найдутся два сообщения с одинаковыми значениями хэш-функций, то есть произойдет коллизия.
Криптографические хэш-функции должны быть равномерными по выходу, насколько это можно проверить, чтобы быть устойчивыми к коллизиям. Следовательно, для нахождения коллизии нужно взять группу из примерно $2^{k/2}$ сообщений. 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=13cm]{questions/img/15_3_1.png}
\end{center}
\end{figure}

\subsection{Хэш-функция Стрибог.}
Как показано на рис. 8.1, входное сообщение разбивается на блоки по 512 бит (64 байта). Последний блок слева дополняется последовательностью из нулей и одной единицы до 512 бит (длина дополнения не учитывается в дальнеи?шем, когда длина сообщения используется как аргумент функций). Для каждой части сообщения вычисляется значение функции $g_N(h,m)$, которая в качестве аргумента использует текущий номер блока (умноженный на 512), результат вычисления для предыдущего блока и очередной блок сообщения. Также есть два завершающих преобразования. вместо блока сообщения использует количество обработанных бит N (то есть длину сообщения), а второе -- арифметическую сумму значений всех блоков сообщения.

\begin{itemize}
\item сложность построения прообраза: $2^n$
\item сложность построения второго прообраза: $2^n/M$
\item сложность построения коллизии: $2^{n/2}$
\item сложность удлинения прообраза: $2^n$
\end{itemize}
\begin{figure}[h!]
\begin{center}
\includegraphics[width=13cm]{questions/img/15_4_1.png}
\end{center}
\end{figure}